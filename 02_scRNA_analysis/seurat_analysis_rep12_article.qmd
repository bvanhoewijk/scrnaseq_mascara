# QC and selecting cells for further analysis
Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include

- The number of unique genes detected in each cell.
  - Low-quality cells or empty droplets will often have very few genes
  - Cell doublets or multiplets may exhibit an aberrantly high gene count
- Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
```{r}
rm(list=ls())

library(dplyr)
library(Seurat)
library(patchwork)

dirs <- setNames(c("/zfs/omics/personal/14015641/projects/single_cell/data/tomato_seurat/rep1/", "/zfs/omics/personal/14015641/projects/single_cell/data/tomato_seurat/rep2/"), c("rep1", "rep2"))

# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = dirs)

	
# min.cells: Include features detected in at least this many cells. Will subset the counts matrix as well. To reintroduce excluded features, create a new object with a lower cutoff
# min.features: Include cells where at least this many features are detected
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "tomato", min.cells = 3, min.features = 200)
pbmc
```

```{r}
tail(rownames(pbmc))
```

```{r}
non_gene <- grep("Solyc", rownames(pbmc), invert = TRUE)
rownames(pbmc)[non_gene] <- paste0("MT:", rownames(pbmc)[non_gene])
```

```{r}
tail(rownames(pbmc))
```
- The percentage of reads that map to the mitochondrial genome
  - Low-quality / dying cells often exhibit extensive mitochondrial contamination
  - We calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features
  - We use the set of all genes starting with MT- as a set of mitochondrial genes

```{r}
pbmc[["percent.MT"]] <- PercentageFeatureSet(pbmc, pattern = "^MT")
```
```{r}
par(mfrow=c(1,1))
hist(pbmc[["percent.MT"]][,1], main="Percentage MT", xlab="percentage", xlim=c(0,10), breaks = 100)
```

```{r}
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.MT"), ncol = 3, pt.size=0)
```

```{r}
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.MT")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

This function calls sctransform::vst. The sctransform package is available at https://github.com/satijalab/sctransform. Use this function as an alternative to the NormalizeData, FindVariableFeatures, ScaleData workflow. Results are saved in a new assay (named SCT by default) with counts being (corrected) counts, data being log1p(counts), scale.data being pearson residuals; sctransform::vst intermediate results are saved in misc slot of new assay.


```{r}
pbmc <- subset(pbmc, subset = nFeature_RNA > 300 & nFeature_RNA < 9000 & percent.MT < 2)
pbmc
```
```{r}
protoplast <- as.list(read.csv("protoplast_induced_genes.txt", header=FALSE))$V1
protoplast <- gsub(pattern="\\.[0-9]+", "", protoplast)

rownames2 <- gsub(pattern="\\.[0-9]+", "", rownames(pbmc))
rownames2 <- gsub(pattern="gene:", "", rownames2)

# To keep:
to_keep <- !(rownames2 %in% protoplast)

pbmc <- pbmc[to_keep,]

table(to_keep)
```



```{r}
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.MT", "percent.CP"), ncol = 4, pt.size=0)
```

- We fix the slope parameter of the GLM to ln(10)
 with log10(total UMI)
 used as the predictor as proposed by Lause et al.
- We utilize an improved parameter estimation procedure that alleviates uncertainty and bias that result from fitting GLM models for very lowly expressed genes.
- We place a lower bound on gene-level standard deviation when calculating Pearson residuals. This prevents genes with extremely low expression (only 1-2 detected UMIs) from having a high pearson residual.
```{r}
# Normalizes, Scales and finds variable features
pbmc <- SCTransform(pbmc, verbose=FALSE, vars.to.regress = c("percent.MT"), return.only.var.genes=FALSE, vst.flavor = "v2")
```


```{r}
# These are now standard steps in the Seurat workflow for visualization and clustering
pbmc <- RunPCA(pbmc, verbose = FALSE, features=VariableFeatures(object=pbmc))
ElbowPlot(pbmc, ndims = 50)
```


```{r}
pbmc <- RunUMAP(pbmc, dims = 1:15, verbose = FALSE)
```
```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:15, verbose = FALSE)
pbmc <- FindClusters(pbmc, verbose = FALSE)
DimPlot(pbmc, label = TRUE)
pbmc$seurat_clusters <- Idents(pbmc)
```


```{r}
#saveRDS(pbmc, file = "pbmd_tomato_rep2.rds")
```

```{r}
seurat_markers <- FindAllMarkers(pbmc, min.pct = 0.1, logfc.threshold = 0.25)
```
# plots
```{r}
DimHeatmap(pbmc, dims = 2, cells = 500, balanced = TRUE)
```

# Part 1B: Single cell cluster annotation

## Chisquare
Clusters were annotated based on the overlap of cluster maker genes and a set of cell type-enriched marker genes from ref.23. 


```{r}
seurat_markers$gene <- gsub("\\..*$", "", seurat_markers$gene)
seurat_markers$gene <- gsub(pattern = "gene:", "", seurat_markers$gene)
seurat_markers <- subset(seurat_markers, p_val_adj < 0.05)
head(seurat_markers)
```

```{r}
library(tidyverse)
signatures <- read.csv("signatures_simplified.tsv", sep="\t")
signatures <- gather(signatures)
colnames(signatures) <- c("Type", "Marker")

# Mutually exclusive:
signatures <- signatures[signatures['Marker'] != "",]
signatures <- signatures[!duplicated(signatures['Marker']),]

# Strip prefix:
signatures$Marker <- gsub(pattern = "gene:", "", signatures$Marker)
table(signatures$Type)
head(signatures)
```
```{R}
signatures <- signatures[signatures$Marker %in% seurat_markers$gene, ]
table(signatures$Type)
```

```{r}
total_genes <- length(signatures$Marker)
tissue_types <- length(unique(signatures$Type))
cat("Total genes : ", total_genes, "\n")
cat("Tissue types: ", tissue_types, "\n")

# Tissue specific markers
all_marker_genes <- signatures['Marker']
result_df <- data.frame()
for(T in unique(signatures$Type)){
    T_markers <- subset(signatures, Type == T)$Marker
    # Seurat defined marker list
    for(C in unique(seurat_markers$cluster)){
        S_markers <- subset(seurat_markers, cluster == C)$gene
        a <- sum(T_markers %in% S_markers)
        b <- length(T_markers) - sum(T_markers %in% S_markers)
        c <- sum(S_markers %in% all_marker_genes$Marker) - a
        d <- sum(!(S_markers %in% all_marker_genes)) / tissue_types

        contingency_table <- matrix(c(a, b, c, d), nrow=2, byrow=TRUE)
        chi_square_test <- chisq.test(contingency_table)$p.value * tissue_types 
        result_df <- rbind(result_df, c(T, C, a, b, c, d, chi_square_test))
    }
}
colnames(result_df) <-  c("TissueType", "SeuratCluster", "O1", "E1", "O2", "E2", "P")
result_df
```
```{r}
# Bonferonni correction
result_df$P <- as.numeric(result_df$P)
result_df$Padj <- result_df$P*length(unique(signatures$Type))

arg_result_max <- data.frame()
for(C in unique(result_df$SeuratCluster)){
    result_subset <- subset(result_df, SeuratCluster == C)
    s <- result_subset[which.max(result_subset$Padj), ]
    arg_result_max <- rbind(arg_result_max, s)
}
arg_result_max
```


```{r}
pbmc$chisquare <- "Unknown"
for(C in unique(arg_result_max$SeuratCluster)){
  res = subset(arg_result_max, SeuratCluster == C)
  if(res$Padj > 0.01){
    pbmc$chisquare[pbmc$seurat_clusters == C] <- res$TissueType[1]
  }
}
table(pbmc$chisquare)
```
```{r}
Idents(pbmc) <- "chisquare"
DimPlot(pbmc, reduction = "umap", label=TRUE) + xlim(-14, 14) + ylim(-14, 14) + ggtitle("Chisquare")
```
```{r}
fig2e_genes <- c("Solyc05g051550","Solyc09g083050","Solyc03g005320","Solyc01g094750","Solyc02g014730","Solyc01g095750","Solyc01g094700","Solyc04g011600","Solyc06g074390","Solyc11g067180","Solyc03g097500","Solyc05g054890","Solyc09g065420","Solyc03g115960")
found <- c()
for(bait in fig2e_genes){
  found <- c(found, rownames(pbmc)[grep(bait, rownames(pbmc))])
  
}
p <- DotPlot(pbmc, features=found) + RotatedAxis() + coord_flip()
p 
```

## Fisher exact test
```{r}
universe <- length(unique(c(signatures$Marker, seurat_markers$gene)))
universe
```

```{r}
total_genes <- length(signatures$Marker)
tissue_types <- length(unique(signatures$Type))

cat("Total genes : ", total_genes, "\n")
cat("Tissue types: ", tissue_types, "\n")
cat("Universe    : ", universe, "\n")
# Tissue specific markers
all_marker_genes <- signatures['Marker']
result_df <- data.frame()
for(T in unique(signatures$Type)){
    T_markers <- subset(signatures, Type == T)$Marker
    # Seurat defined marker list
    for(C in unique(seurat_markers$cluster)){
        S_markers <- subset(seurat_markers, cluster == C)$gene
        
        de_in_set <- length(intersect(S_markers, T_markers))
        de_not_in_set <- length(S_markers) - de_in_set
        not_de_in_set <- length(T_markers) - de_in_set
        not_de_not_in_set <- universe - (de_in_set + de_not_in_set + de_not_in_set)
        
        contingency_table <- matrix(c(de_in_set, de_not_in_set, not_de_in_set, not_de_not_in_set), nrow = 2)   
        result <- fisher.test(contingency_table)

        result_df <- rbind(result_df, c(T, C, de_in_set, de_not_in_set, not_de_in_set, not_de_not_in_set, result$p.value*tissue_types))
    }
}
colnames(result_df) <-  c("TissueType", "SeuratCluster", "O1", "E1", "O2", "E2", "P")
result_df
```

```{r}
arg_result_max <- data.frame()
for(C in unique(result_df$SeuratCluster)){
    result_subset <- subset(result_df, SeuratCluster == C)
    s <- result_subset[which.max(result_subset$P), ]
    arg_result_max <- rbind(arg_result_max, s)
}
arg_result_max$TissueType
```


```{r}
pbmc$fisher <- "Unknown"
for(C in unique(arg_result_max$SeuratCluster)){
  res = subset(arg_result_max, SeuratCluster == C)
  if(res$P > 0.01){
    pbmc$fisher[pbmc$seurat_clusters == C] <- res$TissueType[1]
  }else{
    pbmc$fisher[pbmc$seurat_clusters == C] <- "Unknown"
  }
}
table(pbmc$fisher)
```
```{r}
Idents(pbmc) <- "fisher"
DimPlot(pbmc, reduction = "umap", label=TRUE) + xlim(-14, 14) + ylim(-14, 14) + ggtitle("Fisher exact test")
```
```{r}
fig2e_genes <- c("Solyc05g051550","Solyc09g083050","Solyc03g005320","Solyc01g094750","Solyc02g014730","Solyc01g095750","Solyc01g094700","Solyc04g011600","Solyc06g074390","Solyc11g067180","Solyc03g097500","Solyc05g054890","Solyc09g065420","Solyc03g115960")
found <- c()
for(bait in fig2e_genes){
  found <- c(found, rownames(pbmc)[grep(bait, rownames(pbmc))])
  
}
p <- DotPlot(pbmc, features=found) + RotatedAxis() + coord_flip()
p 
```


## SCSorter

### Prep annotation
```{r}
library(tidyverse)
#anno <-  read.csv('../data/signatures.csv')
anno <-  read.csv('../data/signatures_simplified.tsv', sep="\t")

anno <- gather(anno)
colnames(anno) <- c("Type", "Marker")
anno['Weight'] <- 2

anno <- anno[anno['Marker'] != "",]
anno <- anno[!duplicated(anno$Marker),]

anno$Marker <- paste0("gene:", anno$Marker)
```


```{r}
topgenes <- head(VariableFeatures(pbmc), 3000)
cat(paste0("Number of topgenes: ", length(topgenes)))
```


```{r}
expr <- pbmc[["SCT"]]$scale.data
rownames(expr) <- gsub("\\..$", "", rownames(expr))
topgenes <- gsub("\\..$", "", topgenes)

anno <- anno[anno$Marker %in% rownames(expr),]
```

```{r}
picked_genes = unique(c(anno$Marker, topgenes, anno$Marker[anno$Marker %in% rownames(expr)]))
expr = expr[rownames(expr) %in% picked_genes, ]
anno <- anno[anno$Marker %in% rownames(expr),]
```

```{r}
table(anno$Type)
```


```{R}
library(scSorter)
rts <- scSorter(expr, anno)
```

```{r}
pbmc$CellType <- rts$Pred_Type
Idents(pbmc) <- "CellType"
DimPlot(pbmc, reduction = "umap", label=TRUE) + xlim(-14, 14) + ylim(-14, 14) + ggtitle("scSorter")
```



```{r}
# write_rds(rts, "cellsorter_result_rep12.rds")
rts <- read_rds("cellsorter_result_rep12.rds")
```

```{r}
table(rts$Pred_Type)
```


```{r}
knitr::kable(sort(table(rts$Pred_Type), TRUE))
```

```{r}
found <- c()
for(bait in c("Solyc09g065750","Solyc01g090660","Solyc08g066650","Solyc08g062950")){
  found <- c(found, rownames(pbmc)[grep(bait, rownames(pbmc))])
  
}
DotPlot(pbmc, features=found)+ RotatedAxis() + coord_flip()
```
```{r}
fig2e_genes <- c("Solyc05g051550","Solyc09g083050","Solyc03g005320","Solyc01g094750","Solyc02g014730","Solyc01g095750","Solyc01g094700","Solyc04g011600","Solyc06g074390","Solyc11g067180","Solyc03g097500","Solyc05g054890","Solyc09g065420","Solyc03g115960")
found <- c()
for(bait in fig2e_genes){
  found <- c(found, rownames(pbmc)[grep(bait, rownames(pbmc))])
  
}
p <- DotPlot(pbmc, features=found, scale=TRUE, scale.by='radius') + RotatedAxis() + coord_flip()
p 
```


```{r}
library(ggplot2)
cluster_dataframe <- data.frame(seurat_clusters=pbmc[['seurat_clusters']], cellsorter=rts$Pred_Type)
ggplot(cluster_dataframe, aes(x=seurat_clusters, fill=cellsorter)) + geom_bar(position="fill")
ggplot(cluster_dataframe, aes(x=seurat_clusters, fill=cellsorter)) + geom_bar()
```

## ScType

Are the marker genes actually expressed?
```{r}
signatures <- read.csv("signatures_simplified.tsv", sep="\t")
signatures <- gather(signatures)
colnames(signatures) <- c("Type", "Marker")

# Mutually exclusive:
signatures <- signatures[signatures['Marker'] != "",]
signatures <- signatures[!duplicated(signatures['Marker']),]
signatures$Marker <- gsub(pattern = "gene:", "", signatures$Marker)

DefaultAssay(pbmc) <- "SCT"
expr <- GetAssayData(pbmc)

rownames(expr) <- gsub("\\..*$", "", rownames(expr))
rownames(expr) <- gsub(pattern = "gene:", "", rownames(expr))
expr_mat <- as.matrix(expr)
```

```{r}
# load libraries and functions
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = TRUE)
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R"); 
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

DefaultAssay(pbmc) <- "SCT"
expr <- GetAssayData(pbmc)

var_feat <- VariableFeatures(pbmc, nfeatures=3000)
expr <- expr[rownames(expr) %in% var_feat,]


rownames(expr) <- gsub("\\..*$", "", rownames(expr))
rownames(expr) <- gsub(pattern = "gene:", "", rownames(expr))
expr_mat <- as.matrix(expr)


# load signatures:
signatures <- read.csv("signatures_simplified.tsv", sep="\t")
signatures <- gather(signatures)
colnames(signatures) <- c("Type", "Marker")

# Mutually exclusive:
signatures <- signatures[signatures['Marker'] != "",]
signatures <- signatures[!duplicated(signatures['Marker']),]

# Strip prefix:
signatures$Marker <- gsub(pattern = "gene:", "", signatures$Marker)
table(signatures$Type)

# Select marker genes with more than 2% occurence over cells:
# expr_mat2 <- expr_mat[rownames(expr_mat) %in% signatures[['Marker']],]
# sum(rowSums(expr_mat2) > 1)
# 
# a <- apply(expr_mat2, 1, function(x){sum(x > 1)}) / ncol(expr_mat2)*100
# to_keep <- names(a[a > 2])

anno <- list()
for(type in unique(signatures[["Type"]])){
    selection <- signatures$Marker[signatures["Type"] == type]
    selection <- selection[selection %in% rownames(expr_mat)]
    # selection <- selection[selection %in% to_keep]
    anno[[type]] <- selection
}

```

```{r}
sctype_score <- function(scRNAseqData, scaled = !0, gs, gs2 = NULL, gene_names_to_uppercase = !0, ...){
  
  # check input matrix
  if(!is.matrix(scRNAseqData)){
    warning("scRNAseqData doesn't seem to be a matrix")
  } else {
    if(sum(dim(scRNAseqData))==0){
       warning("The dimension of input scRNAseqData matrix equals to 0, is it an empty matrix?")
    }
  }
  
  # marker sensitivity
  marker_stat = sort(table(unlist(gs)), decreasing = TRUE); 
  marker_sensitivity = data.frame(score_marker_sensitivity = scales::rescale(as.numeric(marker_stat), to = c(0,1), from = c(length(gs),1)),
                                      gene_ = names(marker_stat), stringsAsFactors = !1)

  # subselect genes only found in data
  names_gs_cp = names(gs); names_gs_2_cp = names(gs2);
  gs = lapply(1:length(gs), function(d_){ 
    GeneIndToKeep = rownames(scRNAseqData) %in% as.character(gs[[d_]]); rownames(scRNAseqData)[GeneIndToKeep]})
  gs2 = lapply(1:length(gs2), function(d_){ 
    GeneIndToKeep = rownames(scRNAseqData) %in% as.character(gs2[[d_]]); rownames(scRNAseqData)[GeneIndToKeep]})
  names(gs) = names_gs_cp; names(gs2) = names_gs_2_cp;
  cell_markers_genes_score = marker_sensitivity[marker_sensitivity$gene_ %in% unique(unlist(gs)),]
  
  # z-scale if not
  if(!scaled) Z <- t(scale(t(scRNAseqData))) else Z <- scRNAseqData
  
  # multiple by marker sensitivity
  for(jj in 1:nrow(cell_markers_genes_score)){
    Z[cell_markers_genes_score[jj,"gene_"], ] = Z[cell_markers_genes_score[jj,"gene_"], ] * cell_markers_genes_score[jj, "score_marker_sensitivity"]
  }
  
  # subselect only with marker genes
  Z = Z[unique(c(unlist(gs),unlist(gs2))), ]
  
  # combine scores
  es = do.call("rbind", lapply(names(gs), function(gss_){ 
    sapply(1:ncol(Z), function(j) {
      gs_z = Z[gs[[gss_]], j]; gz_2 = Z[gs2[[gss_]], j] * -1
      sum_t1 = (sum(gs_z) / sqrt(length(gs_z))); sum_t2 = sum(gz_2) / sqrt(length(gz_2));
      if(is.na(sum_t2)){
        sum_t2 = 0;
      }
      sum_t1 + sum_t2
    })
  })) 
  
  dimnames(es) = list(names(gs), colnames(Z))
  es.max <- es[!apply(is.na(es) | es == "", 1, all),] # remove na rows
 
  es.max
}
```

```{r}
es.max <- sctype_score(scRNAseqData = expr_mat, scaled = TRUE, gs = anno)
```

```{r}
cL_resutls <- do.call("rbind", lapply(unique(pbmc@meta.data$seurat_clusters), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(pbmc@meta.data[pbmc@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(pbmc@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells] <- "Unknown"
print(sctype_scores[,1:3])
```

```{r}
pbmc@meta.data$sctype_classification = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  pbmc@meta.data$sctype_classification[pbmc@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

DimPlot(pbmc, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'sctype_classification')  
```
```{r}
table(pbmc@meta.data$sctype_classification)
table(pbmc@meta.data$CellType)
table(pbmc@meta.data$CellTypes2)
table(pbmc@meta.data$CellTypes3)


```

```{r}
fig2e_genes <- c("Solyc05g051550","Solyc09g083050","Solyc03g005320","Solyc01g094750","Solyc02g014730","Solyc01g095750","Solyc01g094700","Solyc04g011600","Solyc06g074390","Solyc11g067180","Solyc03g097500","Solyc05g054890","Solyc09g065420","Solyc03g115960")
Idents(pbmc) <- "sctype_classification"
found <- c()
for(bait in fig2e_genes){
  found <- c(found, rownames(pbmc)[grep(bait, rownames(pbmc))])
  
}
p <- DotPlot(pbmc, features=found, scale=TRUE, scale.by='radius') + RotatedAxis() + coord_flip()
p 
```



# Part 3: TEST
```{r}
nfeat_orig <- VariableFeatures(object=pbmc, nfeatures=3000)
nfeat_trim <- gsub("\\...?", "", nfeat_orig)
to_select  <- nfeat_orig[nfeat_trim %in% anno$Marker]
length(to_select)
```
```{r}
to_select <- tail(nfeat_orig, 2000)
length(tail(nfeat_orig, 2000))
```

```{r}
# These are now standard steps in the Seurat workflow for visualization and clustering
pbmc <- RunPCA(pbmc, verbose = FALSE, features=to_select)
ElbowPlot(pbmc)
```

```{r}
pbmc <- RunUMAP(pbmc, dims = 1:10, verbose = FALSE, n.neighbors = 10, min.dist=0.01)
```
```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:10, verbose = FALSE)
pbmc <- FindClusters(pbmc, verbose = FALSE)
DimPlot(pbmc, label = TRUE)
```
```{r}
pbmc$CellType <- rts$Pred_Type
Idents(pbmc) <- "CellType"
DimPlot(pbmc, reduction = "umap", label=TRUE) + xlim(-14, 14) + ylim(-14, 14)
```
```{r}
PCAPlot(pbmc, dims=c(1,2))
PCAPlot(pbmc, dims=c(2,3))
```

```{r}
save.image("saveworkspace_rep12.RData")
```